// background.js

importScripts('profile.js');
importScripts('supportBackground.js');
importScripts('action.js');
//let campaignUrl = `http://ddl.routerproxy.com:3000/campaignList?campaignID=${profile.Extra}`;
let campaignUrl = 'http://localhost:8080/getCampaign';
let otpUrl = 'http://ddl.routerproxy.com:3000/otp';
let clickUrl = 'http://localhost:8080/click';
let sendUrl = 'http://localhost:8080/send';
let scrollUrl = 'http://localhost:8080/scroll';
let triggerDoneUrl = 'http://localhost:8080/triggerDone';
let setLogUrl = 'http://localhost:8080/setLog';
const apiKey = 'RingoSecretKeyAPI';
let errorSignal = false;
let onCompleted = false;

async function onInstalled() {

  await updateActiveTabUrl('https://www.google.com/');

  chrome.tabs.onUpdated.addListener(firstLoad);
  
}

// Listen for startup
chrome.runtime.onInstalled.addListener(onInstalled);

chrome.webNavigation.onErrorOccurred.addListener(function (details) {

  console.log('onErrorOccurred');
  errorSignal = true;
});

chrome.webNavigation.onCompleted.addListener(function (details) {

  console.log('onCompleted');
  onCompleted = true;
});

async function getActiveTab() {
  let queryOptions = { active: true, lastFocusedWindow: true };
  // `tab` will either be a `tabs.Tab` instance or `undefined`.
  let [tab] = await chrome.tabs.query(queryOptions);
  while (!tab) {
    [tab] = await chrome.tabs.query(queryOptions);
  }
  return tab;
}

async function updateActiveTabUrl(url) {
  let tab = await getActiveTab();
  await chrome.tabs.update(tab.id, { url: url });
}

async function reloadActiveTab() {
  let tab = await getActiveTab();
  await chrome.tabs.reload(tab.id);
}

async function firstLoad(tabId, changeInfo) {
  if (tabId === tabId && changeInfo.status === 'complete') {
    chrome.tabs.onUpdated.removeListener(firstLoad);
    await delaySimple(10000);
    await initCampaign();
  }
}

async function initCampaign() {
  let fetchedCampaign = await fetchCampaign();
  let isViewYoutube = fetchedCampaign.isViewYoutube;
  let isViewNews = fetchedCampaign.isViewNews;
  let isViewWeb = fetchedCampaign.isViewWeb;
  let isLogMail = fetchedCampaign.isLogMail && profile.ID !== '';

  let logMailResult = true;
  if (isLogMail) {
    
    logMailResult = await logMail();
  }

  if (logMailResult) {

    if (isLogMail) {

      await checkLanguage();
    }

    if (isViewNews) {

      await randomAction();
    }

    if (isViewYoutube) {

      await viewYoutube();
    }

    if (isViewWeb) {

      await viewWeb();
    }

    await fetchSetLog("");
  } else {
    
    if (isViewWeb) {
      if (isViewNews) await randomAction();
      await viewWeb();
    }
    await fetchSetLog("Log Fail");
  }

  await delaySimple(10000);

  await fetchTriggerDone();
}

async function waitForLoad() {
  console.log('start waitForLoad');
  if (errorSignal){
    console.log('1st waitForLoad false');
    errorSignal = false;
    onCompleted = false;
    return false;
  }

  let tab = await getActiveTab();
  
  while (tab.status !== 'complete' && !onCompleted) {
    tab = await getActiveTab();
    console.log(tab.status + " | " + onCompleted);
    if (errorSignal){
      console.log('2nd waitForLoad false');
      errorSignal = false;
      onCompleted = false;
      return false;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  
  console.log('waitForLoad true');
  onCompleted = false;
  return true;
}

async function fetchTriggerDone() {
  while (true) {
    try {
      let response = await fetch(triggerDoneUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT }),
      });
      let data = await response.text();
      console.log(data);
      return data;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchSetLog(log) {
  while (true) {
    try {
      let response = await fetch(setLogUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, Log: log }),
      });
      let data = await response.text();
      console.log(data);
      return data;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchClickRandomReal(selector, maxWaitTime = 10000) {
  while (true) {
    try {
      if (!(await waitForLoad())){
        return;
      }
      if (await fetchFindElement(selector, maxWaitTime)) {
        console.log('found');
        let elementData = await fetchGetDistanceToRandomElement(selector);
        console.log(elementData.distance);
        await fetchScrollReal(elementData.distance);
        let coordinate = await fetchGetRandomVisibleElementPositionOnScreen(selector);
        console.log(coordinate);
        while (!coordinate) {
          await reloadActiveTab();
          elementData = await fetchGetDistanceToRandomElement(selector);
          console.log(elementData.distance);
          await fetchScrollReal(elementData.distance);
          coordinate = await fetchGetRandomVisibleElementPositionOnScreen(selector);
        }
        let response = await fetch(clickUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY }),
        });
        let data = await response.text();
        
        await delaySimple(random(postDelayMin, postDelayMax));
        return data;
      }
      console.log('not found');
      return false;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}


async function fetchClickReal(selector, maxWaitTime = 10000, containerSelector = null) {
  while (true) {
    try {
      if (!(await waitForLoad())){
        return;
      }
      if (await fetchFindElement(selector, maxWaitTime)) {
        if (!(await fetchIsElementVisible(selector, containerSelector))) {
          let data = await fetchGetDistanceToElement(selector, containerSelector);
          await fetchScrollReal(data.distance, data.specialCoordinate);
        }
        let coordinate = await fetchGetElementPositionOnScreen(selector);
        console.log(coordinate);
        let response = await fetch(clickUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY }),
        });
        let data = await response.text();
        await delaySimple(random(postDelayMin, postDelayMax));
        return data;
      }
      return false;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchClickByTextReal(selector, textToFind, maxWaitTime = 10000, containerSelector = null) {
  while (true) {
    try {
      if (!(await waitForLoad())){
        return;
      }
      if (await fetchFindElementByText(selector, textToFind, maxWaitTime)) {
        if (!(await fetchIsElementVisibleByText(selector, textToFind, containerSelector))) {
          let data = await fetchGetDistanceToElementByText(selector, textToFind, containerSelector);
          await fetchScrollReal(data.distance, data.specialCoordinate);
        }
        let coordinate = await fetchGetElementPositionOnScreen(selector);
        console.log(coordinate);
        let response = await fetch(clickUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY }),
        });
        let data = await response.text();
        await delaySimple(random(postDelayMin, postDelayMax));
        return data;
      }
      return false;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchSendTextReal(selector, textToType, maxWaitTime = 10000) {
  while (true) {
    try {
      if (!(await waitForLoad())){
        return;
      }
      if (await fetchFindElement(selector, maxWaitTime)) {
        if (!(await fetchIsElementVisible(selector))) {
          let data = await fetchGetDistanceToElement(selector);
          await fetchScrollReal(data.distance);
        }
        let coordinate = await fetchGetElementPositionOnScreen(selector);

        let normalizedText = removeDiacritics(textToType);

        let response = await fetch(sendUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY, textToType: normalizedText }),
        });
        let data = await response.text();
        await delaySimple(random(postDelayMin, postDelayMax));
        return data;
      }
      return false;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchScrollReal(distance, specialCoordinate = null) {
  while (true) {
    try {
      if (!(await waitForLoad())){
        return;
      };
      console.log('fetchScrollReal');
      let coordinate = await fetchGetPositionOnScreen();
      let screenX = coordinate.screenX
      let screenY = coordinate.screenY
      if (specialCoordinate) {
        screenX = specialCoordinate.screenX
        screenY = specialCoordinate.screenY
      }
      let response = await fetch(scrollUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: screenX, screenY: screenY, distance: distance }),
      });
      let data = await response.text();

      await delaySimple(random(postDelayMin, postDelayMax));
      return data;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchCampaign() {
  while (true) {
    try {
      // if (!(await waitForLoad())){
      //   return;
      // };
      console.log('fetchCampaign');
      let response = await fetch(campaignUrl, {
        method: 'GET'
        // headers: {
        //   'api-key': apiKey
        // }
      });

      let data = await response.json();
      console.log(data);
      return data;
    } catch (error) {
      console.log('fetch failed: ' + error);
    }
    await delaySimple(10000);
  }
}

async function fetchOtp(secret) {
  try {
    if (!(await waitForLoad())){
      return;
    };
    console.log('fetchOtp');
    secret = secret.replace(/\s/g, '');
    let response = await fetch(otpUrl, {
      method: 'POST',
      headers: {
        'api-key': apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ secret: secret }),
    });

    let data = await response.json();
    let otp = data.otp;

    if (otp) {
      return otp;
    } else {
      return false;
    }
  } catch (error) {
    return false;
  }
}

async function fetchGetCurrentUrl(log) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getCurrentUrl, log: log });
  return response.result;
}

async function fetchSendLog(log) {
  if (!(await waitForLoad())){
    return;
  };
  console.log('fetchSendLog');
  let tab = await getActiveTab();
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.sendLog, log: log });
  return response.result;
}

async function fetchNavigate(url, isHref = false) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchNavigate');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.navigate, url: url, isHref: isHref });
  //await delay(random(postDelayMin, postDelayMax));
  return response.result;
}

async function fetchGetHrefElements(selector) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('getHrefElements');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getHrefElements, selector: selector });
  return response.result;
}

async function fetchQuickScanElement(selector) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('quickScanElement');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.quickScanElement, selector: selector });
  return response.result;
}

async function fetchQuickScanElementByText(selector, textToFind) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchQuickScanElementByText');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.quickScanElementByText, selector: selector, textToFind: textToFind });
  return response.result;
}

async function fetchGetElementPositionOnScreen(selector, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetElementPositionOnScreen');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getElementPositionOnScreen, selector: selector, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchGetRandomVisibleElementPositionOnScreen(selector, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetRandomVisibleElementPositionOnScreen');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getRandomVisibleElementPositionOnScreen, selector: selector, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchGetPositionOnScreen() {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetPositionOnScreen');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getPositionOnScreen });
  return response.result;
}

async function fetchFindElement(selector, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchFindElement');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElement, selector: selector, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchFindElementByText(selector, textToFind, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchFindElementByText');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchFindElements(selector, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchFindElements');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElements, selector: selector, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchFindElementsByText(selector, textToFind, maxWaitTime = 10000) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchFindElementsByText');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementsByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
  return response.result;
}

async function fetchIsElementVisible(selector, containerSelector = null) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchIsElementVisible');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisible, selector: selector, containerSelector: containerSelector });
  return response.result;
}

async function fetchIsElementVisibleByText(selector, textToFind, containerSelector = null) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchIsElementVisibleByText');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisible, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
  return response.result;
}

async function fetchGetDistanceToRandomElement(selector) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetDistanceToRandomElement');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToRandomElement, selector: selector });
  return { distance: response.result };
}

async function fetchGetDistanceToElement(selector, containerSelector = null) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetDistanceToElement');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElement, selector: selector, containerSelector: containerSelector });
  return { distance: response.result, specialCoordinate: response.specialCoordinate };
}

async function fetchGetDistanceToElementByText(selector, textToFind, containerSelector = null) {
  if (!(await waitForLoad())){
    return;
  };
  let tab = await getActiveTab();
  console.log('fetchGetDistanceToElementByText');
  let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElementByText, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
  return { distance: response.result, specialCoordinate: response.specialCoordinate };
}

// async function fetchScroll(distance, containerSelector = null) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchScroll');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.scroll, distance: distance, containerSelector: containerSelector });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchClick(selector, maxWaitTime = 10000, containerSelector = null) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchClick');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.click, selector: selector, maxWaitTime: maxWaitTime, containerSelector: containerSelector });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchClickByText(selector, textToFind, maxWaitTime = 10000, containerSelector = null) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchClickByText');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.clickByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime, containerSelector: containerSelector });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchClickByElement(elementToInteract, containerSelector = null) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchClickByElement');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.clickByElement, elementToInteract: elementToInteract, containerSelector: containerSelector });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchClickRandom(selector, maxWaitTime = 10000, containerSelector = null) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchClick');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.clickRandom, selector: selector, maxWaitTime: maxWaitTime, containerSelector: containerSelector });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchSendText(selector, textToType, maxWaitTime = 10000) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchSendText');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.sendText, selector: selector, textToType: textToType, maxWaitTime: maxWaitTime });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// async function fetchSendTextByText(selector, textToType, textToFind, maxWaitTime = 10000) {
//   await waitForLoad();
//   let tab = await getActiveTab();
//   console.log('fetchSendTextByText');
//   let response = await chrome.tabs.sendMessage(tab.id, { action: actions.sendTextByText, selector: selector, textToFind: textToFind, textToType: textToType, maxWaitTime: maxWaitTime });
//   //await delay(random(postDelayMin, postDelayMax));
//   return response.result;
// }

// chrome.webNavigation.onDOMContentLoaded.addListener(test);

// async function test(details) {
//   if (details.frameId === 0) {
//     await delay(10000);
//     await fetchNavigate('https://www.pacific-college.edu/blog/jobs-you-can-get-with-business-administration-degree');
//     console.log('test');
//     console.log('test');
//     await updateActiveTabUrl('https://www.google.com/?hl=en');
//     //await fetchCampaign();
//   }
// }
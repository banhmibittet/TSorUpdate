let eventDelayMin = 50;
let eventDelayMax = 200;
let moveEventDelayMin = 10;
let moveEventDelayMax = 20;
let wheelEventDelayMin = 200;
let wheelEventDelayMax = 300;
let postDelayMin = 1000;
let postDelayMax = 2000;

let scrollDownDistanceMin = 500;
let scrollDownDistanceMax = 1500;
let scrollUpDistanceMax = -1500;
let scrollUpDistanceMin = -500;

let actions = {
    getCurrentUrl: 'getCurrentUrl',
    sendLog: 'sendLog',
    //click: 'click',
    //clickByText: 'clickByText',
    //clickByElement: 'clickByElement',
    //clickRandom: 'clickRandom',
    //sendText: 'sendText',
    //sendTextByText: 'sendTextByText',
    quickScanElement: 'quickScanElement',
    quickScanElementByText: 'quickScanElementByText',
    getHrefElements: 'getHrefElements',
    getElementPositionOnScreen: 'getElementPositionOnScreen',
    getRandomVisibleElementPositionOnScreen: 'getRandomVisibleElementPositionOnScreen',
    getPositionOnScreen: 'getPositionOnScreen',
    findElement: 'findElement',
    findElementByText: 'findElementByText',
    findElements: 'findElements',
    findElementsByText: 'findElementsByText',
    navigate: 'navigate',
    isElementVisible: 'isElementVisible',
    isElementVisibleByText: 'isElementVisibleByText',
    getDistanceToElement: 'getDistanceToElement',
    getDistanceToRandomElement: 'getDistanceToRandomElement',
    getDistanceToElementByText: 'getDistanceToElementByText',
    //scroll: 'scroll'
};

// // Patch isTrusted to TRUE
// function patchTrusted() {
//   Element.prototype._addEventListener = Element.prototype.addEventListener;
//   Element.prototype.addEventListener = function () {
//     let args = [...arguments]
//     let temp = args[1];
//     args[1] = function () {
//       let args2 = [...arguments];
//       args2[0] = Object.assign({}, args2[0])
//       args2[0].isTrusted = true;
//       return temp(...args2);
//     }
//     return this._addEventListener(...args);
//   }
// }

// function delay(time) {
//     return new Promise(resolve => setTimeout(resolve, time));
// }

async function delaySimple(time) {
    console.log(`Delaying for ${time} milliseconds...`);
    const chunkSize = 1000; // Delay in 1000ms (1 second) chunks
    const numChunks = time / chunkSize;
    
    console.log('loop delay simple');
    for (let i = 0; i < numChunks; i++) {
        await new Promise((resolve) => setTimeout(resolve, chunkSize));
        console.log(`Delaying for ${time} milliseconds...`);
    }
    
    console.log(`Delay completed for ${time} milliseconds.`);
}

async function delay(time) {
    console.log('start delay');
    await fetchSendLog(`Delaying for ${time} milliseconds...`);
    //console.log(`Delaying for ${time} milliseconds...`);
    const chunkSize = 1000; // Delay in 1000ms (1 second) chunks
    const numChunks = time / chunkSize;
    
    console.log('loop delay');
    for (let i = 0; i < numChunks; i++) {
        await new Promise((resolve) => setTimeout(resolve, chunkSize));
        await fetchSendLog(`Completed ${i + 1} of ${numChunks} chunks.`);
        //console.log(`Completed ${i + 1} of ${numChunks} chunks.`);
    }

    console.log('finish delay');
    await fetchSendLog(`Delay completed for ${time} milliseconds.`);
    //console.log(`Delay completed for ${time} milliseconds.`);
}

function random(min, max) {
    return Math.random() * (max - min) + min;
}

function randomRoll() {
    // Generate a random number between 0 and 99
    return Math.floor(Math.random() * 100);
}

function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}

function randomPickInArray(value) {
    return value[Math.floor(Math.random() * value.length)];
}

function removeDiacritics(text) {
    return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}


// background.js

importScripts('profile.js');
importScripts('supportBackground.js');
importScripts('action.js');
//let campaignUrl = `http://ddl.routerproxy.com:3000/campaignList?campaignID=${profile.Extra}`;
let campaignUrl = 'http://localhost:8080/getCampaign';
let otpUrl = 'http://localhost:8080/getOtp';
let clickUrl = 'http://localhost:8080/click';
let sendUrl = 'http://localhost:8080/send';
let sendBrowserUrl = 'http://localhost:8080/sendBrowser';
let scrollUrl = 'http://localhost:8080/scroll';
let triggerDoneUrl = 'http://localhost:8080/triggerDone';
let uploadVideoUrl = 'http://localhost:8080/uploadVideo';
let countUsedMusicUrl = 'http://localhost:8080/countUsedMusic';
let setLogUrl = 'http://localhost:8080/setLog';
let setHistoryUrl = 'http://localhost:8080//setHistory';
const apiKey = 'RingoSecretKeyAPI';
let errorOccurred = false;
let onCompleted = false;

let mainTab;
//let subTab;

async function createOffscreen() {
  await chrome.offscreen.createDocument({
    url: 'offscreen.html',
    reasons: ['BLOBS'],
    justification: 'keep service worker running',
  }).catch(() => { });
}

chrome.runtime.onStartup.addListener(createOffscreen);
self.onmessage = e => { }; // keepAlive
createOffscreen();

async function onInstalled() {
  await delay(10000);
  await fetchSendTextBrowserReal('https://www.google.com');
  await delay(10000);
  await initCampaign();
}

function getBrowserNavigateBarPosition() {
  return new Promise((resolve, reject) => {
    chrome.windows.getCurrent(function (currentWindow) {
      if (currentWindow) {
        // Get the vertical position of the top edge of the browser window on the screen
        let screenY = currentWindow.top + 60;
        // Calculate the horizontal position of the middle edge of the browser window on the screen
        let screenX = currentWindow.left + currentWindow.width / 2;

        // Resolve the promise with the position object
        resolve({ screenX, screenY });
      } else {
        // Reject the promise if window information cannot be retrieved
        reject(new Error('Unable to get window information.'));
      }
    });
  });
}


// Listen for startup
chrome.runtime.onInstalled.addListener(onInstalled);

chrome.webNavigation.onErrorOccurred.addListener(function (details) {

  if (details.frameId === 0) {
    console.log('onErrorOccurred ' + details.error);
    errorOccurred = true;
  }
});

chrome.webNavigation.onCompleted.addListener(function (details) {

  if (details.frameId === 0) {
    console.log('onCompleted');
    onCompleted = true;
  }
});

async function openTab(url) {
  // Create a new tab and open the specified URL.
  const newTab = await chrome.tabs.create({ url: url });
  return newTab;
}

async function switchActiveToTab(tab) {
  await chrome.tabs.update(tab.id, { active: true });
}

async function getActiveTab() {
  let queryOptions = { active: true, lastFocusedWindow: true };
  // `tab` will either be a `tabs.Tab` instance or `undefined`.
  let [tab] = await chrome.tabs.query(queryOptions);
  while (!tab) {
    [tab] = await chrome.tabs.query(queryOptions);
  }
  return tab;
}

async function updateActiveTabUrl(url) {
  let tab = await getActiveTab();
  await chrome.tabs.update(tab.id, { url: url });
  await delay(random(postDelayMin, postDelayMax));
}

async function reloadActiveTab() {
  let tab = await getActiveTab();
  await chrome.tabs.reload(tab.id);
  await delay(random(postDelayMin, postDelayMax));
}

async function initCampaign() {
  console.log('initCampaign');

  let fetchedCampaign = await fetchCampaign();
  errorOccurred = false;
  let isViewYoutube = fetchedCampaign.isViewYoutube;
  let isViewNews = fetchedCampaign.isViewNews;
  let isViewWeb = fetchedCampaign.isViewWeb;
  let isUploadTiktok = fetchedCampaign.isUploadTiktok;
  let isLogMail = fetchedCampaign.isLogMail && profile.ID !== '';
  //let isSubTab = fetchedCampaign.isSubTab;

  mainTab = await getActiveTab();
  // if (isSubTab) {
  //   subTab = await openTab('https://www.google.com/');
  //   await switchActiveToTab(mainTab);
  // }

  let logMailResult = true;
  if (isLogMail) {

    logMailResult = await logMail();
  }

  if (logMailResult) {

    if (isLogMail) {

      await checkLanguage();
    }

    if (isViewNews) {

      await randomAction();
    }

    if (isViewYoutube) {

      await viewYoutube();
    }

    if (isViewWeb) {

      await viewWeb();
    }

    let uploadTikTokResult;
    if (isUploadTiktok){
      uploadTikTokResult = await uploadTiktok();
    }

    if (uploadTikTokResult == 'OutTiktok'){
      await fetchSetLog("OutTiktok");
    } else if (uploadTikTokResult == 'Unavailable'){
      await fetchSetLog("Unavailable");
    } else {
      await fetchSetLog("");
    }

  } else {

    if (isViewWeb) {
      if (isViewNews) await randomAction();
      await viewWeb();
    }
    await fetchSetLog("Log Fail");
  }

  if (isViewYoutube) {
    await fetchSetHistoryPool(profile.HistoryPool);
  }

  await delay(10000);

  await fetchTriggerDone();
}

async function waitForLoad() {

  if (errorOccurred) {
    console.log('1st waitForLoad false');
    errorOccurred = false;
    onCompleted = false;
    return false;
  }

  let tab = await getActiveTab();

  while (tab.status !== 'complete' && !onCompleted) {
    tab = await getActiveTab();

    console.log(tab.status + " | " + onCompleted);
    if (errorOccurred) {
      console.log('2nd waitForLoad false');
      errorOccurred = false;
      onCompleted = false;
      return false;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }


  onCompleted = false;
  return true;
}

async function fetchTriggerDone() {
  return await executeWithRetry(async () => {
    console.log('fetchTriggerDone');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(triggerDoneUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log(data);
    return data;
  }, 'fetchTriggerDone');
}

async function fetchUploadVideoRandomReal() {
  return await executeWithRetry(async () => {
    console.log('fetchUploadVideoRandomReal');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(uploadVideoUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log(data);
    return data;
  }, 'fetchTriggerDone');
}

async function fetchSetLog(log) {
  return await executeWithRetry(async () => {
    console.log('fetchSetLog');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(setLogUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, Log: log }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log(data);
    return data;
  }, 'fetchSetLog');
}

async function fetchCountUsedMusic(music) {
  return await executeWithRetry(async () => {
    console.log('fetchCountUsedMusic');

    let normalizedText = removeDiacritics(music);
    
    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(countUsedMusicUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, Music: normalizedText }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log(data);
    return data;
  }, 'fetchCountUsedMusic');
}

async function fetchSetHistoryPool(historyPool) {
  return await executeWithRetry(async () => {
    console.log('fetchSetHistoryPool');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(setHistoryUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, HistoryPool: historyPool }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log(data);
    return data;
  }, 'fetchSetHistoryPool');
}

async function fetchClickRandomReal(selector, maxWaitTime = 10000, isClick = true) {
  return await executeWithRetry(async () => {
    console.log('fetchClickRandomReal');
    if (!(await waitForLoad())) {
      return;
    }
    if (await fetchFindElement(selector, maxWaitTime)) {
      //console.log('found');
      let elementData = await fetchGetDistanceToRandomElement(selector);
      //console.log(elementData.distance);
      await fetchScrollReal(elementData.distance);
      let coordinate = await fetchGetRandomVisibleElementPositionOnScreen(selector);
      //console.log(coordinate);
      while (!coordinate) {
        await reloadActiveTab();
        elementData = await fetchGetDistanceToRandomElement(selector);
        //console.log(elementData.distance);
        await fetchScrollReal(elementData.distance);
        coordinate = await fetchGetRandomVisibleElementPositionOnScreen(selector);
      }

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(clickUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY , isClick: isClick}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();

      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    console.log('not found');
    return false;
  }, 'fetchClickRandomReal');
}


async function fetchClickReal(selector, maxWaitTime = 10000, containerSelector = null, isClick = true) {
  return await executeWithRetry(async () => {
    console.log('fetchClickReal');
    if (!(await waitForLoad())) {
      return;
    }
    if (await fetchFindElement(selector, maxWaitTime)) {
      if (!(await fetchIsElementVisible(selector, containerSelector))) {
        let data = await fetchGetDistanceToElement(selector, containerSelector);
        await fetchScrollReal(data.distance, data.specialCoordinate);
      }
      let coordinate = await fetchGetElementPositionOnScreen(selector);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(clickUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY , isClick: isClick}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchClickReal');
}

async function fetchClickRealInFrame(iframeSelector, selector, maxWaitTime = 10000, containerSelector = null, isClick = true) {
  return await executeWithRetry(async () => {
    console.log('fetchClickRealInFrame');
    if (!(await waitForLoad())) {
      return;
    }
    if (await fetchFindElementInFrame(iframeSelector, selector, maxWaitTime)) {
      if (!(await fetchIsElementVisibleInFrame(iframeSelector, selector, containerSelector))) {
        let data = await fetchGetDistanceToElementInFrame(iframeSelector, selector, containerSelector);
        await fetchScrollReal(data.distance, data.specialCoordinate);
      }
      let coordinate = await fetchGetElementPositionOnScreenInFrame(iframeSelector, selector);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(clickUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY , isClick: isClick}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchClickReal');
}

async function fetchClickByTextReal(selector, textToFind, maxWaitTime = 10000, containerSelector = null, isClick = true) {
  return await executeWithRetry(async () => {
    console.log('fetchClickByTextReal');
    if (!(await waitForLoad())) {
      return;
    }

    if (await fetchFindElementByText(selector, textToFind, maxWaitTime)) {
      if (!(await fetchIsElementVisibleByText(selector, textToFind, containerSelector))) {
        let data = await fetchGetDistanceToElementByText(selector, textToFind, containerSelector);
        await fetchScrollReal(data.distance, data.specialCoordinate);
      }
      let coordinate = await fetchGetElementPositionOnScreenByText(selector, textToFind);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(clickUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY , isClick: isClick}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchClickByTextReal');
}

async function fetchClickByTextRealInFrame(iframeSelector, selector, textToFind, maxWaitTime = 10000, containerSelector = null, isClick = true) {
  return await executeWithRetry(async () => {
    console.log('fetchClickByTextRealInFrame');
    if (!(await waitForLoad())) {
      return;
    }

    if (await fetchFindElementByTextInFrame(iframeSelector, selector, textToFind, maxWaitTime)) {
      if (!(await fetchIsElementVisibleByTextInFrame(iframeSelector, selector, textToFind, containerSelector))) {
        let data = await fetchGetDistanceToElementByTextInFrame(iframeSelector, selector, textToFind, containerSelector);
        await fetchScrollReal(data.distance, data.specialCoordinate);
      }
      let coordinate = await fetchGetElementPositionOnScreenByTextInFrame(iframeSelector, selector, textToFind);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(clickUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY , isClick: isClick}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchClickByTextRealInFrame');
}

async function fetchSendTextReal(selector, textToType, maxWaitTime = 10000, isEnter = false) {
  return await executeWithRetry(async () => {
    console.log('fetchSendTextReal');
    if (!(await waitForLoad())) {
      return;
    }

    if (await fetchFindElement(selector, maxWaitTime)) {
      if (!(await fetchIsElementVisible(selector))) {
        let data = await fetchGetDistanceToElement(selector);
        await fetchScrollReal(data.distance);
      }
      let coordinate = await fetchGetElementPositionOnScreen(selector);

      let normalizedText = removeDiacritics(textToType);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(sendUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY, textToType: normalizedText, isEnter: isEnter}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchSendTextReal');
}

async function fetchSendTextRealInFrame(iframeSelector, selector, textToType, maxWaitTime = 10000, isEnter = false) {
  return await executeWithRetry(async () => {
    console.log('fetchSendTextRealInFrame');
    if (!(await waitForLoad())) {
      return;
    }

    if (await fetchFindElementInFrame(iframeSelector, selector, maxWaitTime)) {
      if (!(await fetchIsElementVisibleInFrame(iframeSelector, selector))) {
        let data = await fetchGetDistanceToElementInFrame(iframeSelector, selector);
        await fetchScrollReal(data.distance);
      }
      let coordinate = await fetchGetElementPositionOnScreenInFrame(iframeSelector, selector);

      let normalizedText = removeDiacritics(textToType);

      let controller = new AbortController();
      setTimeout(() => controller.abort(), 30000);

      let response = await fetch(sendUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY, textToType: normalizedText, isEnter: isEnter}),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Status: ${response.status}`);
      }

      let data = await response.text();
      await delay(random(postDelayMin, postDelayMax));
      return data;
    }
    return false;
  }, 'fetchSendTextRealInFrame');
}

async function fetchSendTextBrowserReal(textToType) {
  return await executeWithRetry(async () => {
    console.log('fetchSendTextBrowserReal');
    
    // TODO - Get Coordinate of navigate bar
    let coordinate = await getBrowserNavigateBarPosition();

    let normalizedText = removeDiacritics(textToType);

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);
    let response = await fetch(sendBrowserUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, screenX: coordinate.screenX, screenY: coordinate.screenY, textToType: normalizedText }),
      signal: controller.signal,
    });
    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }
    let data = await response.text();
    await delay(random(postDelayMin, postDelayMax));
    return data;
  }, 'fetchSendTextBrowserReal');
}

async function fetchScrollReal(distance, specialCoordinate = null) {
  return await executeWithRetry(async () => {
    console.log('fetchScrollReal');
    if (!(await waitForLoad())) {
      return;
    };

    let coordinate = await fetchGetPositionOnScreen();
    let screenX = coordinate.screenX
    let screenY = coordinate.screenY
    if (specialCoordinate) {
      screenX = specialCoordinate.screenX
      screenY = specialCoordinate.screenY
    }

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let verticalDistance, horizontalDistance;
    if (typeof distance === 'object' && distance !== null && 'vertical' in distance && 'horizontal' in distance) {
      verticalDistance = distance.vertical;
      horizontalDistance = distance.horizontal;
    } else {
      verticalDistance = distance;
      horizontalDistance = 0;
    }

    let response = await fetch(scrollUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, screenX: screenX, screenY: screenY, verticalDistance: verticalDistance, horizontalDistance: horizontalDistance }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();

    await delay(random(postDelayMin, postDelayMax));
    return data;
  }, 'fetchScrollReal');
}

async function fetchCampaign() {
  return await executeWithRetry(async () => {
    console.log('fetchCampaign');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(campaignUrl, {
      method: 'GET',
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.json();
    console.log('fetchCampaign ' + data);
    return data;
  }, 'fetchCampaign');
}

async function fetchOtp(secret) {
  return await executeWithRetry(async () => {
    console.log('fetchOtp');
    if (!(await waitForLoad())) {
      return;
    };

    secret = secret.replace(/\s/g, '');

    let controller = new AbortController();
    setTimeout(() => controller.abort(), 30000);

    let response = await fetch(otpUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ STT: profile.STT, secret: secret }),
      signal: controller.signal,
    });

    if (!response.ok) {
      throw new Error(`Status: ${response.status}`);
    }

    let data = await response.text();
    console.log('fetchOtp ' + data);
    return data;
  }, 'fetchOtp');
}

async function fetchGetCurrentUrl() {
  return await executeWithRetry(async () => {
    console.log('fetchGetCurrentUrl');
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();
    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getCurrentUrl });
    console.log('fetchGetCurrentUrl' + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetCurrentUrl');
}

async function fetchSendLog(log) {
  return await executeWithRetry(async () => {
    console.log('fetchSendLog');
    if (!(await waitForLoad())) {
      return;
    };

    let tab = await getActiveTab();
    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.sendLog, log: log });
    console.log('fetchSendLog' + ' result: ' + response.result);
    return response.result;
  }, 'fetchSendLog');
}

async function fetchNavigate(url, isHref = false) {
  return await executeWithRetry(async () => {
    console.log('fetchNavigate ' + url);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.navigate, url: url, isHref: isHref });
    await delay(random(postDelayMin, postDelayMax));
    return response.result;
  }, 'fetchNavigate');
}

async function fetchGetHrefElements(selector) {
  return await executeWithRetry(async () => {
    console.log('fetchGetHrefElements ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getHrefElements, selector: selector });
    console.log('fetchGetHrefElements ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetHrefElements');
}

async function fetchQuickScanElement(selector) {
  return await executeWithRetry(async () => {
    console.log('fetchQuickScanElement ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.quickScanElement, selector: selector });
    console.log('fetchQuickScanElement ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchQuickScanElement');
}

async function fetchQuickScanElementByText(selector, textToFind) {
  return await executeWithRetry(async () => {
    console.log('fetchQuickScanElementByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.quickScanElementByText, selector: selector, textToFind: textToFind });
    console.log('fetchQuickScanElementByText ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchQuickScanElementByText');
}

async function fetchGetElementPositionOnScreen(selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchGetElementPositionOnScreen' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getElementPositionOnScreen, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchGetElementPositionOnScreen' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetElementPositionOnScreen');
}

async function fetchGetElementPositionOnScreenInFrame(iframeSelector, selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchGetElementPositionOnScreenInFrame' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getElementPositionOnScreenInFrame, iframeSelector: iframeSelector, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchGetElementPositionOnScreenInFrame' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetElementPositionOnScreenInFrame');
}

async function fetchGetElementPositionOnScreenByText(selector, textToFind, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchGetElementPositionOnScreenByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getElementPositionOnScreenByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
    console.log('fetchGetElementPositionOnScreenByText ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetElementPositionOnScreenByText');
}

async function fetchGetElementPositionOnScreenByTextInFrame(iframeSelector, selector, textToFind, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchGetElementPositionOnScreenByTextInFrame ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getElementPositionOnScreenByTextInFrame, iframeSelector: iframeSelector , selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
    console.log('fetchGetElementPositionOnScreenByTextInFrame ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetElementPositionOnScreenByTextInFrame');
}

async function fetchGetRandomVisibleElementPositionOnScreen(selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchGetRandomVisibleElementPositionOnScreen ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getRandomVisibleElementPositionOnScreen, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchGetRandomVisibleElementPositionOnScreen ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetRandomVisibleElementPositionOnScreen');
}

async function fetchGetPositionOnScreen() {
  return await executeWithRetry(async () => {
    console.log('fetchGetPositionOnScreen');
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getPositionOnScreen });
    console.log('fetchGetPositionOnScreen' + ' result: ' + response.result);
    return response.result;
  }, 'fetchGetPositionOnScreen');
}

async function fetchFindElement(selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElement ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();
    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElement, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchFindElement ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElement');
}

async function fetchFindElementInFrame(iframeSelector, selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElementInFrame ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();
    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementInFrame, iframeSelector: iframeSelector, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchFindElementInFrame ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElementInFrame');
}

async function fetchFindElementByText(selector, textToFind, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElementByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
    console.log('fetchFindElementByText ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElementByText');
}

async function fetchFindElementByTextInFrame(iframeSelector, selector, textToFind, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElementByTextInFrame ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementByTextInFrame, iframeSelector: iframeSelector, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
    console.log('fetchFindElementByTextInFrame ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElementByTextInFrame');
}

async function fetchFindElements(selector, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElements ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElements, selector: selector, maxWaitTime: maxWaitTime });
    console.log('fetchFindElements ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElements');
}

async function fetchFindElementsByText(selector, textToFind, maxWaitTime = 10000) {
  return await executeWithRetry(async () => {
    console.log('fetchFindElementsByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.findElementsByText, selector: selector, textToFind: textToFind, maxWaitTime: maxWaitTime });
    console.log('fetchFindElementsByText ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchFindElementsByText');
}

async function fetchIsElementVisible(selector, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchIsElementVisible ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisible, selector: selector, containerSelector: containerSelector });
    console.log('fetchIsElementVisible ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchIsElementVisible');
}

async function fetchIsElementVisibleInFrame(iframeSelector, selector, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchIsElementVisibleInFrame ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisibleInFrame, iframeSelector: iframeSelector, selector: selector, containerSelector: containerSelector });
    console.log('fetchIsElementVisibleInFrame ' + selector + ' result: ' + response.result);
    return response.result;
  }, 'fetchIsElementVisibleInFrame');
}

async function fetchIsElementVisibleByText(selector, textToFind, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchIsElementVisibleByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisibleByText, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
    console.log('fetchIsElementVisibleByText ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchIsElementVisibleByText');
}

async function fetchIsElementVisibleByTextInFrame(iframeSelector, selector, textToFind, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchIsElementVisibleByTextInFrame ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.isElementVisibleByTextInFrame, iframeSelector: iframeSelector, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
    console.log('fetchIsElementVisibleByTextInFrame ' + textToFind + ' result: ' + response.result);
    return response.result;
  }, 'fetchIsElementVisibleByTextInFrame');
}

async function fetchGetDistanceToRandomElement(selector) {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToRandomElement ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToRandomElement, selector: selector });
    console.log('fetchGetDistanceToRandomElement ' + selector + ' result: ' + response.result);
    return { distance: response.result };
  }, 'fetchGetDistanceToRandomElement');
}

async function fetchGetDistanceToElement(selector, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToElement ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElement, selector: selector, containerSelector: containerSelector });
    console.log('fetchGetDistanceToElement ' + selector + ' result: ' + response.result);
    return { distance: response.result, specialCoordinate: response.specialCoordinate };
  }, 'fetchGetDistanceToElement');
}

async function fetchGetDistanceToElementInFrame(iframeSelector, selector, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToElementInFrame ' + selector);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElementInFrame, iframeSelector: iframeSelector, selector: selector, containerSelector: containerSelector });
    console.log('fetchGetDistanceToElementInFrame ' + selector + ' result: ' + response.result);
    return { distance: response.result, specialCoordinate: response.specialCoordinate };
  }, 'fetchGetDistanceToElementInFrame');
}

async function fetchGetDistanceToElementByText(selector, textToFind, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToElementByText ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElementByText, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
    console.log('fetchGetDistanceToElementByText ' + textToFind + ' result: ' + response.result);
    return { distance: response.result, specialCoordinate: response.specialCoordinate };
  }, 'fetchGetDistanceToElementByText');
}

async function fetchGetDistanceToElementByTextInFrame(iframeSelector, selector, textToFind, containerSelector = null) {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToElementByTextInFrame ' + textToFind);
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToElementByTextInFrame, iframeSelector: iframeSelector, selector: selector, textToFind: textToFind, containerSelector: containerSelector });
    console.log('fetchGetDistanceToElementByTextInFrame ' + textToFind + ' result: ' + response.result);
    return { distance: response.result, specialCoordinate: response.specialCoordinate };
  }, 'fetchGetDistanceToElementByTextInFrame');
}

async function fetchGetDistanceToBottom() {
  return await executeWithRetry(async () => {
    console.log('fetchGetDistanceToBottom');
    if (!(await waitForLoad())) {
      return;
    };
    let tab = await getActiveTab();

    let response = await chrome.tabs.sendMessage(tab.id, { action: actions.getDistanceToBottom });
    console.log('fetchGetDistanceToBottom result: ' + response.result);
    return { distance: response.result };
  }, 'fetchGetDistanceToBottom');
}
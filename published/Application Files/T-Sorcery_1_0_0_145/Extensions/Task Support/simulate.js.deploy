function simulateFindElementByText(selector, textToFind, maxWaitTime = 10000) {
  return new Promise((resolve) => {
    let pollingInterval = 1000; // Polling interval in milliseconds
    let checkElement = () => {
      let elements = document.querySelectorAll(selector);
      let result;
      for (let element of elements) {
        if (element.offsetParent !== null) {
          // Element is visible, add it to the results
          if (element.textContent.includes(textToFind)) {
            result = element; // Element exists
          }
        }
      }
      //console.log(result);

      if (result) {
        resolve(result);
      } else if (maxWaitTime <= 0) {
        resolve(result);  // Element doesn't exist, and timeout occurred
      } else {
        // Continue polling
        setTimeout(checkElement, pollingInterval);
        maxWaitTime -= pollingInterval;
      }
    };

    // Start the initial check
    checkElement();
  });
}

function simulateFindElementsByText(selector, textToFind, maxWaitTime = 10000) {
  return new Promise((resolve) => {
    let pollingInterval = 1000; // Polling interval in milliseconds
    let checkElement = () => {
      let elements = document.querySelectorAll(selector);
      let result = [];
      for (let element of elements) {
        if (element.offsetParent !== null) {
          // Element is visible, add it to the results
          if (element.textContent.includes(textToFind)) {
            result.push(element); // Element exists
          }
        }
      }
      //console.log(result);

      if (result) {
        resolve(result);
      } else if (maxWaitTime <= 0) {
        resolve(result);  // Element doesn't exist, and timeout occurred
      } else {
        // Continue polling
        setTimeout(checkElement, pollingInterval);
        maxWaitTime -= pollingInterval;
      }
    };

    // Start the initial check
    checkElement();
  });
}

function simulateFindElement(selector, maxWaitTime = 10000) {
  return new Promise((resolve) => {
    let pollingInterval = 1000; // Polling interval in milliseconds

    let checkElement = () => {
      let elements = document.querySelectorAll(selector);
      let result;
      for (let element of elements) {
        if (element.offsetParent !== null) {
          // Element is visible, add it to the results
          result = element;
        }
      }
      //console.log(result);
      if (result) {
        resolve(result); // Element exists
      } else if (maxWaitTime <= 0) {
        resolve(result); // Element doesn't exist, and timeout occurred
      } else {
        // Continue polling
        setTimeout(checkElement, pollingInterval);
        maxWaitTime -= pollingInterval;
      }
    };

    // Start the initial check
    checkElement();
  });
}

function simulateFindElements(selector, maxWaitTime = 10000) {
  return new Promise((resolve) => {
    let pollingInterval = 1000; // Polling interval in milliseconds

    let checkElement = () => {
      let elements = document.querySelectorAll(selector);
      let result = [];
      for (let element of elements) {
        if (element.offsetParent !== null) {
          // Element is visible, add it to the results
          result.push(element);
        }
      }
      //console.log(result);
      if (result) {
        resolve(result); // Element exists
      } else if (maxWaitTime <= 0) {
        resolve(result); // Element doesn't exist, and timeout occurred
      } else {
        // Continue polling
        setTimeout(checkElement, pollingInterval);
        maxWaitTime -= pollingInterval;
      }
    };

    // Start the initial check
    checkElement();
  });
}

function simualteNavigate(url, isHref) {
  if (isHref) {
    window.location.href = url;
  } else {
    window.location.assign(url);
  }
}

async function simulateGetElementPositionOnScreen(selector, maxWaitTime = 10000) {
  let elementToInteract = await simulateFindElement(selector, maxWaitTime);
  if (elementToInteract) {
    // Get the height of the entire browser window
    let windowHeight = window.outerHeight;

    // Get the height of the viewport (the visible area)
    let viewportHeight = window.innerHeight;

    // Calculate the height of the window header
    let windowHeaderHeight = windowHeight - viewportHeight;

    // Button bounds relative to viewport  
    let elementRect = elementToInteract.getBoundingClientRect();

    // Calculate the padding as a fraction of the element's dimensions
    const paddingFraction = 0.4; // Adjust this value as needed (0.1 represents 10% padding)

    // Calculate the padding based on the element's size
    const paddingX = elementRect.width * paddingFraction;
    const paddingY = elementRect.height * paddingFraction;

    // Choose a random destination position within the element
    let screenX = window.screenX + elementRect.left + paddingX + Math.random() * (elementRect.width - 2 * paddingX);
    let screenY = window.screenY + elementRect.top + windowHeaderHeight + paddingY + Math.random() * (elementRect.height - 2 * paddingY);

    screenX = clamp(screenX, 0, 1920);
    screenY = clamp(screenY, 0, 1080);
    // Return the position as an object
    return { screenX, screenY };
  } else {
    return false;
  }
}

async function simulateGetElementPositionOnScreenByElement(elementToInteract) {
  // Get the height of the entire browser window
  let windowHeight = window.outerHeight;

  // Get the height of the viewport (the visible area)
  let viewportHeight = window.innerHeight;

  // Calculate the height of the window header
  let windowHeaderHeight = windowHeight - viewportHeight;

  // Button bounds relative to viewport  
  let elementRect = elementToInteract.getBoundingClientRect();

  // Calculate the padding as a fraction of the element's dimensions
  const paddingFraction = 0.4; // Adjust this value as needed (0.1 represents 10% padding)

  // Calculate the padding based on the element's size
  const paddingX = elementRect.width * paddingFraction;
  const paddingY = elementRect.height * paddingFraction;

  // Choose a random destination position within the element
  let screenX = window.screenX + elementRect.left + paddingX + Math.random() * (elementRect.width - 2 * paddingX);
  let screenY = window.screenY + elementRect.top + windowHeaderHeight + paddingY + Math.random() * (elementRect.height - 2 * paddingY);

  screenX = clamp(screenX, 0, 1920);
  screenY = clamp(screenY, 0, 1080);
  // Return the position as an object
  return { screenX, screenY };
}

async function simulateGetPositionOnScreen() {
  // Get the height of the entire browser window
  let windowHeight = window.outerHeight;

  // Get the height of the viewport (the visible area)
  let viewportHeight = window.innerHeight;

  // Calculate the height of the window header
  let windowHeaderHeight = windowHeight - viewportHeight;

  // Calculate the padding as a fraction of the element's dimensions
  const paddingFraction = 0.3; // Adjust this value as needed (0.1 represents 10% padding)

  // Calculate the padding based on the element's size
  const paddingX = window.innerWidth * paddingFraction;
  const paddingY = window.innerHeight * paddingFraction;

  // Choose a random destination position within the element
  let screenX = window.screenX + paddingX + Math.random() * (window.innerWidth - 2 * paddingX);
  let screenY = window.screenY + windowHeaderHeight + paddingY + Math.random() * (window.innerHeight - 2 * paddingY);

  screenX = clamp(screenX, 0, 1920);
  screenY = clamp(screenY, 0, 1080);
  // Return the position as an object
  return { screenX, screenY };
}

// Function to check if an element is visible in the viewport
function simulateIsElementVisibleByElement(elementToInteract, specialContainer = null) {
  let elementRect = elementToInteract.getBoundingClientRect();
  if (specialContainer) {
    let containerRect = specialContainer.getBoundingClientRect();
    return (
      elementRect.top >= containerRect.top &&
      elementRect.left >= containerRect.left &&
      elementRect.bottom <= containerRect.bottom &&
      elementRect.right <= containerRect.right
    );
  }
  return (
    elementRect.top >= 0 &&
    elementRect.left >= 0 &&
    elementRect.bottom <= window.innerHeight &&
    elementRect.right <= window.innerWidth
  );
}

// async function simulateScrollElementIntoView(elementToInteract, specialContainer = null) {
//   // Now simulateScroll the target element into view
//   let elementRect = elementToInteract.getBoundingClientRect();

//   let viewportCenterMin = window.innerHeight / 4;
//   let viewportCenterMax = window.innerHeight / 4 * 3;
//   let viewportCenter = random(viewportCenterMin, viewportCenterMax);
//   let scrollDistance = elementRect.top - viewportCenter + elementRect.height / 2;

//   if (specialContainer) {
//     let specialContainerRect = specialContainer.getBoundingClientRect();
//     viewportCenterMin = specialContainerRect.height / 4;
//     viewportCenterMax = specialContainerRect.height / 4 * 3;
//     viewportCenter = random(viewportCenterMin, viewportCenterMax);
//     scrollDistance = elementRect.top - specialContainerRect.top - viewportCenter + elementRect.height / 2;
//   }

//   await simulateScroll(scrollDistance, specialContainer);
// }

async function simulateGetDistanceToElement(elementToInteract, specialContainer = null) {
  // Now simulateScroll the target element into view
  let elementRect = elementToInteract.getBoundingClientRect();

  let viewportCenterMin = window.innerHeight / 4;
  let viewportCenterMax = window.innerHeight / 4 * 3;
  let viewportCenter = random(viewportCenterMin, viewportCenterMax);
  let scrollDistance = elementRect.top - viewportCenter + elementRect.height / 2;

  if (specialContainer) {
    let specialContainerRect = specialContainer.getBoundingClientRect();
    viewportCenterMin = specialContainerRect.height / 4;
    viewportCenterMax = specialContainerRect.height / 4 * 3;
    viewportCenter = random(viewportCenterMin, viewportCenterMax);
    scrollDistance = elementRect.top - specialContainerRect.top - viewportCenter + elementRect.height / 2;
  }

  return scrollDistance;
  //await simulateScroll(scrollDistance, specialContainer);
}

// async function simulateScroll(distance, specialContainer = null) {
//   let speed = 100;
//   let scrollableElement = document.documentElement;
//   if (specialContainer) {
//     scrollableElement = specialContainer;
//   }
//   // Determine the direction of scrolling
//   let direction = distance > 0 ? 1 : -1;

//   // Calculate the number of steps based on distance and speed, rounded
//   let baseSteps = Math.abs(distance / speed);
//   let finalSteps;
//   if (baseSteps - Math.floor(baseSteps) >= 0.5) {
//     finalSteps = Math.ceil(baseSteps)
//   } else {
//     finalSteps = Math.floor(baseSteps)
//   }

//   let deltaY = speed * direction;

//   for (let step = 1; step <= finalSteps; step++) {
//     // Create and dispatch a custom wheel event
//     scrollableElement.scrollBy({ top: deltaY, behavior: 'smooth' });
//     let wheelEvent = new WheelEvent('wheel', {
//       deltaX: 0,
//       deltaY: deltaY,
//       deltaZ: 0,
//       bubbles: true,
//       cancelable: true,
//     });
//     scrollableElement.dispatchEvent(wheelEvent);

//     await delay(wheelEventDelayMin, wheelEventDelayMax);
//   }
// }

// async function simulateClickByElement(elementToInteract, containerSelector = null) {
//   // Find specialContainer if needed
//   let specialContainer;
//   if (containerSelector) {
//     specialContainer = await simulateFindElement(containerSelector);
//   }

//   // Check if element is visible to user
//   if (!simulateIsElementVisibleByElement(elementToInteract, specialContainer)) {
//     await simulateScrollElementIntoView(elementToInteract, specialContainer);
//   }

//   // Get the dimensions of the element
//   let elementRect = elementToInteract.getBoundingClientRect();

//   // Choose a random starting position along one of the edges
//   let edge = Math.floor(Math.random() * 4); // 0 for top, 1 for right, 2 for bottom, 3 for left
//   let startX, startY;
//   switch (edge) {
//     case 0: // Top edge
//       startX = elementRect.left + Math.random() * elementRect.width;
//       startY = elementRect.top;
//       break;
//     case 1: // Right edge
//       startX = elementRect.right;
//       startY = elementRect.top + Math.random() * elementRect.height;
//       break;
//     case 2: // Bottom edge
//       startX = elementRect.left + Math.random() * elementRect.width;
//       startY = elementRect.bottom;
//       break;
//     case 3: // Left edge
//       startX = elementRect.left;
//       startY = elementRect.top + Math.random() * elementRect.height;
//       break;
//   }

//   // Choose a random destination position within the element
//   let destX = elementRect.left + Math.random() * elementRect.width;
//   let destY = elementRect.top + Math.random() * elementRect.height;

//   // Simulate mouseenter
//   let mouseenterEvent = new MouseEvent('mouseenter', {
//     bubbles: true,
//     cancelable: true,
//     clientX: startX,
//     clientY: startY
//   });
//   elementToInteract.dispatchEvent(mouseenterEvent);

//   let offSetX = startX;
//   let offSetY = startY;

//   while (Math.abs(offSetX - destX) > 1 || Math.abs(offSetY - destY) > 1) {
//     //console.log(`offSetX: ${offSetX} | offSetY: ${offSetY}`);
//     // Calculate the next step size randomly
//     let randomStepSize = random(1, 10); // Adjust the range as needed

//     // Calculate the direction vector (dx, dy) towards the destination
//     let directionX = destX - offSetX;
//     let directionY = destY - offSetY;

//     // Calculate the magnitude of the direction vector
//     let magnitude = Math.sqrt(directionX * directionX + directionY * directionY);

//     // Calculate the unit vector (ux, uy) representing the direction
//     let unitX = directionX / magnitude;
//     let unitY = directionY / magnitude;

//     // Introduce a small random deviation to the direction vector
//     let deviationX = (Math.random() - 0.5); // Adjust the range and factor as needed
//     let deviationY = (Math.random() - 0.5); // Adjust the range and factor as needed

//     // Calculate the new position (x, y) based on the unit vector, step size, and randomness
//     let newX = offSetX + (unitX + deviationX) * randomStepSize;
//     let newY = offSetY + (unitY + deviationY) * randomStepSize;

//     // Ensure the new position is within the bounds of the element
//     let clampedX = clamp(newX, elementRect.left, elementRect.right);
//     let clampedY = clamp(newY, elementRect.top, elementRect.bottom);

//     // Update the current position
//     offSetX = clampedX;
//     offSetY = clampedY;

//     // Simulate the `mousemove` event to move to the new position
//     let mousemoveEvent = new MouseEvent('mousemove', {
//       bubbles: true,
//       cancelable: true,
//       clientX: offSetX,
//       clientY: offSetY,
//     });
//     elementToInteract.dispatchEvent(mousemoveEvent);

//     await delay(random(moveEventDelayMin, moveEventDelayMax));
//   }

//   await delay(random(eventDelayMin, eventDelayMax));
//   // Simulate click
//   let mousedownEvent = new MouseEvent('mousedown', {
//     bubbles: true,
//     cancelable: true,
//     clientX: offSetX,
//     clientY: offSetY,
//   });
//   elementToInteract.dispatchEvent(mousedownEvent);

//   //await new Promise((resolve) => setTimeout(resolve, randomDelay));
//   await delay(random(eventDelayMin, eventDelayMax));
//   // Simulate mouseup with the same coordinates
//   let mouseupEvent = new MouseEvent('mouseup', {
//     bubbles: true,
//     cancelable: true,
//     clientX: offSetX,
//     clientY: offSetY,
//   });
//   elementToInteract.dispatchEvent(mouseupEvent);

//   //await new Promise((resolve) => setTimeout(resolve, randomDelay));
//   // Simulate click with the same coordinates
//   let clickEvent = new MouseEvent('click', {
//     bubbles: true,
//     cancelable: true,
//     clientX: offSetX,
//     clientY: offSetY,
//   });
//   elementToInteract.dispatchEvent(clickEvent);

//   // Optionally, set focus on the element (if it's a focusable element)
//   elementToInteract.focus();

// }

// async function simulateClick(selector, maxWaitTime = 10000, containerSelector = null) {
//   let elementToInteract = await simulateFindElement(selector, maxWaitTime);
//   if (elementToInteract) {
//     await simulateClickByElement(elementToInteract, containerSelector);
//     return true;
//   } else {
//     return false;
//   }
// }

// async function simulateClickByText(selector, textToFind, maxWaitTime = 10000, containerSelector = null) {
//   let elementToInteract = await simulateFindElementByText(selector, textToFind, maxWaitTime);
//   if (elementToInteract) {
//     await simulateClickByElement(elementToInteract, containerSelector);
//     return true;
//   } else {
//     return false;
//   }
// }

// async function simulateSendTextByElement(elementToInteract, textToType) {
//   await simulateClickByElement(elementToInteract);
//   for (let char of textToType) {
//     await simulateKeyboardPress(elementToInteract, char);

//     // Introduce random mistakes (e.g., 5% chance of making a mistake)
//     if (Math.random() < 0.05) {
//       // Generate a random incorrect character
//       let incorrectChar = String.fromCharCode(Math.floor(Math.random() * 26) + 97); // Random lowercase letter
//       await simulateKeyboardPress(elementToInteract, incorrectChar);

//       // Remove incorrect character
//       await simulateKeyboardPress(elementToInteract, 'Backspace');
//     }
//   }

//   // Simulate blurring from the input field
//   let blurEvent = new FocusEvent('blur');
//   elementToInteract.dispatchEvent(blurEvent);

//   // Trigger a final 'input' event to signal the completion of input
//   let inputEvent = new InputEvent('input', {
//     bubbles: true,
//     cancelable: true,
//   });
//   elementToInteract.dispatchEvent(inputEvent);

// }

// async function simulateSendText(selector, textToType, maxWaitTime = 10000) {
//   let elementToInteract = await simulateFindElement(selector, maxWaitTime);
//   if (elementToInteract) {
//     await simulateSendTextByElement(elementToInteract, textToType);
//     return true;
//   } else {
//     return false;
//   }
// }

// async function simulateSendTextByText(selector, textToFind, textToType, maxWaitTime = 10000) {
//   let elementToInteract = await simulateFindElementByText(selector, textToFind, maxWaitTime);
//   if (elementToInteract) {
//     await simulateSendTextByElement(elementToInteract, textToType);
//     return true;
//   } else {
//     return false;
//   }
// }

// async function simulateKeyboardPress(elementToInteract, char) {
//   // Simulate typing the character
//   let keydownEvent = new KeyboardEvent('keydown', {
//     bubbles: true,
//     cancelable: true,
//     key: char
//   });
//   elementToInteract.dispatchEvent(keydownEvent);

//   let keypressEvent = new KeyboardEvent('keypress', {
//     bubbles: true,
//     cancelable: true,
//     key: char
//   });
//   elementToInteract.dispatchEvent(keypressEvent);

//   if (char == 'Backspace') {
//     elementToInteract.value = elementToInteract.value.slice(0, -1);
//   } else {
//     elementToInteract.value += char;
//   }

//   // Trigger a final 'input' event to signal the completion of input
//   let inputEvent = new InputEvent('input', {
//     bubbles: true,
//     cancelable: true,
//   });
//   elementToInteract.dispatchEvent(inputEvent);

//   //await new Promise((resolve) => setTimeout(resolve, randomDelay));
//   await delay(random(eventDelayMin, eventDelayMax));

//   // Simulate releasing the key
//   let keyupEvent = new KeyboardEvent('keyup', {
//     bubbles: true,
//     cancelable: true,
//     key: char
//   });
//   elementToInteract.dispatchEvent(keyupEvent);
// }

// async function simulateClickRandom(selector, maxWaitTime = 10000, containerSelector = null) {
//   let elements = await simulateFindElements(selector, maxWaitTime);
//   if (elements.length > 0) {
//     await simulateClickByElement(randomPickInArray(elements), containerSelector);
//     return true;
//   } else {
//     return false;
//   }
// }
